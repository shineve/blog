{"pages":[],"posts":[{"title":"Clipboard API - Copy text to clipboard with JavaScript","text":"Copy buttons are often used in many websites and applications, in this tutorial, you would learn how to copy text in your website or web app across all browsers. Demo The Wide Support WayTo appreciate the improved way of copying text to clipboard, we need to take a brief look at how we used to have to do things. 123456789101112131415161718192021222324function wideSupportCopyToClipboard(textToCopy) { // Add a temporary textarea element so that we can later run the copy command const textarea = document.createElement('textarea'); //Add value we want to copy to the textarea textarea.value = textToCopy; // Avoid keyboard open in iOS textarea.readOnly = true; textarea.contentEditable = 'true'; //Append invisible textarea to the document textarea.style.position = 'absolute'; textarea.style.left = '-9999px'; document.body.appendChild(textarea); //select the text to be copied textarea.select(); // Copy the selected text inside the textarea to the clipboard document.execCommand('copy'); //Remove temporary textarea from the document textarea.remove();} Clipboard APIThe Clipboard API to provide copy, cut and paste events as well as provide access to the OS clipboard. This API is intended to replace the need of the document.execCommand() method which is now being deprecated. The awesome part of the Clipboard API is that it provides Async Clipboard API with a well-defined permissions model that doesn’t block the page, it allows us to provide better user experience when transferring time consuming resources. You can check for more details here. The Clipboard API browser compatibility is also now supported in major browsers after Safari recently announced support for it in version 13.1. The New Way12345678910function newWayCopyToClipboard(textToCopy) { navigator.clipboard .writeText(textToCopy) .then(() =&gt; { console.log(&quot;Text copied to clipboard&quot;); }) .catch((error) =&gt; { console.error(&quot;Failed to copy: &quot;, error); });} FinalWe can keep the wide support version to make sure everything goes well when something goes wrong. 12345678910111213async function copyToClipboard(textToCopy) { if (navigator.clipboard &amp;&amp; navigator.clipboard.writeText) { try { await navigator.clipboard.writeText(textToCopy); console.log(&quot;Text copied to clipboard with Clipboard API&quot;); } catch { console.error(&quot;Failed to copy: &quot;, error); wideSupportCopyToClipboard(textToCopy); } } else { wideSupportCopyToClipboard(textToCopy); }} Resources MDN - Clipboard API MDN - Clipboard.writeText() Can I Use - Clipboard API browser Compatibility Unblocking clipboard access - Safer, unblocked clipboard access for text and images","link":"/clipboard-api/"},{"title":"CSS Postprocessor (PostCSS)","text":"以最知名的 PostCSS 為例，它是一個使用 JavaScript 轉換 CSS 的工具，它提供很多的API來分析、修改CSS的規則，因此它可以被利用來開發各種的工具，在拓展性極高的狀況下，它其實並不局限在於後處理。 以下是較常見的 PostCSS Plugins： autoprefixer: 加入各家瀏覽器的前綴詞（prefix），例如：-webkit-、-moz-。 stylelint: 語法檢查和報錯。 postcss-preset-env: 將先進的功能轉為目前主流瀏覽器所能支援的語法。（類似 Babel） postcss-nested: 提供 CSS Nesting 功能。 cssnano: 在不改變CSS的效果為前提下，對CSS檔案做縮減及優化。 Lost Grid: 讓系統支援 Grid System。（通過 calc() 實現因此支援度很高） 優勢 有彈性、好擴充，因為是以 Plugin 的方式插入，未來若主流瀏覽器支援了這些功能，要拔除特定 plugin 是很容易的。 更輕量，不像 Sass 可能預先綁了許多可能用不到的功能。 速度快。由於 PostCSS 的功能由所掛的 Plugin 數量而定，體積小，因此轉換的速度幾乎比 Sass 快三倍。 相對 CSS Preprocessor，更容易撰寫自己所想要的功能，因為使用 PostCSS 是可以自建 Plugin 而不是修改 Library。 Vue 中 PostCSS 的應用 Vue CLI 中就有使用到上方所提的 autoprefixer，來擴大專案的瀏覽器支援度 。 Vue 中有一個非常實用的 Scoped CSS 功能，讓各個 Component 之間的 CSS 不會互相污染，而這項功能正是透過 PostCSS 的協助來完成的。","link":"/css-postprocessor/"},{"title":"CSS Preprocessor","text":"以最知名的 Sass 為例，它提供了許多 CSS 語法的擴充，彌補 CSS 在大型專案維護性的不足，讓開發者可以更有結構地撰寫簡潔、清晰且好維護的 CSS 程式碼。 Sass 常用的有幾種功能： Variables：變數中可以儲存顏色、字型或任何 CSS 值。 Nesting：可巢狀 CSS 選擇器，提供清晰的層次結構。 Mixins：可以定義&amp;重用程式碼塊。 Extend：可以在一個選擇器內繼承另一個選擇器。 Operators：可以在 CSS 中使用操作符進行計算。 @if and @else / @for：可以迴圈/條件生成 CSS。 CSS Preprocessor 可以解決什麼問題？01. 文件切分當頁面越來越複雜，需要加載的 CSS 文件也越來越大，我們有必要把大文件切分開來，否則難以維護。傳統的 CSS 文件切分方案基本上就是 CSS 原生的 @import 指令，或在 HTML 中加載多個 CSS 文件，這些方案通常不能滿足性能要求。 CSS Preprocessor擴展了 @import 指令的能力，通過編譯環節將切分後的文件重新合併為一個大文件。這一方面解決了大文件不便維護的問題，另一方面也解決了一堆小文件在加載時的性能問題。 02. CSS Nesting當我們在撰寫 HTML 時，可以輕易的寫出 DOM 之間嵌套的階層結構，但在傳統的 CSS 做不到，需要重複寫許多父元素選擇器。 12345678910111213.nav { margin: auto; width: 1000px; color: #333;} .nav li { float: left; width: 100px;} .nav li a { display: block; text-decoration: none;} 依賴 CSS Preprocessor 可以直接像在寫程式一樣將父子元素這樣一層一層包起來。這樣我們可以很容易地表達出規則之間的層級關係。 12345678910111213.nav { margin: auto; width: 1000px; color: #333; li { float: left; width: 100px; a { display: block; text-decoration: none; } }} 03. CSS 的重複利用Extends / Mixins 讓 CSS 能更好的被複用，以提高 CSS 的可維護性。Extends 與 Mixins 的最大區別就是 Mixins 可以傳入參數，Extends 只是單純繼承，與 TailwindCSS 的 @apply 效果相同 Mixins 1234567891011121314151617// Mixins@mixin square($size, $radius: 0) { width: $size; height: $size; @if $radius != 0 { border-radius: $radius; }}.avatar { @include square(100px, $radius: 4px);}.card { @include square(300px, $radius: 2px);} 123456789101112// Mixins transpiled result.avatar { width: 100px; height: 100px; border-radius: 4px;}.card { width: 300px; height: 300px; border-radius: 2px;} Extends 123456789101112131415161718192021222324252627282930// Extends%message-shared { border: 1px solid #ccc; padding: 10px; color: #333;}%equal-heights { display: flex; flex-wrap: wrap;}.message { @extend %message-shared;}.success { @extend %message-shared; border-color: green;}.error { @extend %message-shared; border-color: red;}.warning { @extend %message-shared; border-color: yellow;} 123456789101112131415161718// Extends transpiled result.warning, .error, .success, .message { border: 1px solid #ccc; padding: 10px; color: #333;}.success { border-color: green;}.error { border-color: red;}.warning { border-color: yellow;} 推薦閱讀風格指南 Sass Style Guide 專案結構 The 7-1 Pattern 1234567891011121314151617181920212223242526272829303132333435363738sass/||– abstracts/ （or utilities/)| |– _variables.scss // Sass Variables| |– _functions.scss // Sass Functions| |– _mixins.scss // Sass Mixins||– base/| |– _reset.scss // Reset/normalize| |– _typography.scss // Typography rules||– components/ (or modules/)| |– _buttons.scss // Buttons| |– _carousel.scss // Carousel| |– _slider.scss // Slider||– layout/| |– _navigation.scss // Navigation| |– _grid.scss // Grid system| |– _header.scss // Header| |– _footer.scss // Footer| |– _sidebar.scss // Sidebar| |– _forms.scss // Forms||– pages/| |– _home.scss // Home specific styles| |– _about.scss // About specific styles| |– _contact.scss // Contact specific styles||– themes/| |– _theme.scss // Default theme| |– _admin.scss // Admin theme||– vendors/| |– _bootstrap.scss // Bootstrap| |– _jquery-ui.scss // jQuery UI|`– main.scss // Main Sass file","link":"/css-preprocessor/"},{"title":"GitHub &amp; Jira Automation","text":"Automation had been setup in DEV project, if you pass in a valid ticket ID, the referenced issue will transit automatically depending on your action to save you a little time to adjust the issue status yourself. Check out GitHub actions if you are interested how the automation works. What is a ticket ID?You can find the ticket ID from the bottom left corner of your issue card. ticket ID example: NGT-194 is the ticket ID. How to name your branch1&lt;ticket-id&gt;/&lt;branch-type&gt;_&lt;branch-name&gt; (**DEV-112/feature_user-login**) Supported Actions Create Branches Branch name example: DEV-112/feature_user-login Issue will automatically transit from To Do to In Progress . Create Commits Commit name example: “DEV-112 Initial commit” Issue will automatically transit from To Do to In Progress . Create Pull Requests Pull Requests name example: “[DEV-112] Feature Login User” Multiple Issues example: “[DEV-111 DEV-112 DEV-113] Feature User Management” All Issues will automatically transit from In Progress to Code Review . Pull Requests Approved Issue will automatically transit from Code Review to Deploy . Pull Requests Declined Issue will automatically transit from Code Review to In Progress . View the development panelIf everything has been set up correctly, you will see a development panel on each of your issues, similar to the screenshot below. The development panel provides you with just enough information to evaluate the status of an issue’s development at a glance. ResourcesHow To Reference issues in Jira Process issues with smart commits","link":"/github-and-jira-automation/"},{"title":"How Vue Scoped CSS Works?","text":"Vue 中的 Scoped CSS 是透過 HTML 的 data-* attribute 來達成的，data-* attribute 讓我們可以在 HTML Element 上自定義添加一些自己需要用到的屬性名稱，以方便自己容易理解。 123&lt;div class=&quot;example&quot; data-source=&quot;facebook&quot;&gt; &lt;span&gt;Text from Facebook&lt;/span&gt;&lt;/div&gt; 它也支援我們透過 CSS 和 JavaScript 來取得 data-* attribute 的屬性值。 透過 CSS 取得或選取 data-*attribute我們可以透過 CSS Attribute Selectors來選取指定的 Element。 1234/* CSS */.example[data-source=&quot;facebook&quot;] { color: blue;} 使用 JS 取得 data-* attribute 的屬性值當我們要取得 data-* attribute 的屬性值時，我們可以簡單利用 JavaScript 中的 dataset 物件，就可以取得其中的內容。 123// Javascriptconst el = document.querySelector('.example');console.log(el.dataset.source) // facebook Scoped CSS in VueVue 在打包時，每個 .vue 檔的會根使用當前檔案的 hash 來做為 [data-* attribute]，綁定在在每一個 Element 及 CSS selector 上，來達到 Component 之間互不污染的效果。 123456789101112131415161718// Parent.vue //&lt;template&gt; &lt;div class=&quot;example&quot;&gt;I'm a &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'Parent', };&lt;/script&gt;// Notice the `scoped` attribute on the style tag.&lt;style scoped&gt; .example { font-size: 1.5em; background-color: blue; }&lt;/style&gt; Transpiled: 12345678910111213141516171819// Parent.vue (transpiled) //&lt;template&gt; // 可以看到這邊產生了一個 data-* attribute &lt;div class=&quot;example&quot; data-v-123456&gt;I'm a &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'Parent', };&lt;/script&gt;&lt;style scoped&gt; /* 可以看到這邊產生了一個 data-* attribute */ .example[data-v-123456] { font-size: 1.5em; background-color: blue; }&lt;/style&gt;","link":"/how-vue-css-scoped-works/"},{"title":"New JavaScript Features in ES6 ~ ES12","text":"This article includes the most commonly used features released from ES6 to ES12. To use those features in front end, you will need to use the babel to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. ES6 / ES20151. class12345678910class Man { constructor(name) { this.name = name; } console() { console.log(this.name); }}const man = new Man('Hao');man.console(); // Hao 2. ES Module12345// export function in module Aexport const sub = (a, b) =&gt; a + b;// import function in module Bimport { sub } from './A';console.log(sub(1, 2)); // 3 3. Arrow functions12const func = (a, b) =&gt; a + b;func(1, 2); // 3 4. Default parameters123function foo(age = 25) { console.log(age); // 25} 5. Template strings123const name = 'Hao';const str = `Your name is ${name}`;console.log(str); // Your name is Hao 6. Destructuring assignment12let a = 1, b= 2;[a, b] = [b, a]; // a 2 b 1 7. Spread operator1let a = [...'hello world']; // [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;] 8. Object property value shorthand123const name = 'Hao',const obj = { name };console.log(obj); // { name: 'Hao' } 9. Promise123Promise.resolve().then(() =&gt; { console.log(2); });console.log(1);// print 1 ，then 2 10. let &amp; const12let name = 'Hao'；const arr = []; ES7 / ES20161. Array.prototype.includes()1[1].includes(1); // true 2. Exponentiation operator123console.log(2 ** 10); // 1024console.log(3 ** 4); // 81console.log(2 ** 3 ** 2); // 512 ES8 / ES20171. async/await1234async getData(){ const res = await api.getTableData(); // await asynchronous task // do something} 2. Object.values()1Object.values({a: 1, b: 2, c: 3}); // [1, 2, 3] 3. Object.entries()1Object.entries({a: 1, b: 2, c: 3}); // [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]] 4. String padding1234// padStart'hello'.padStart(10); // &quot; hello&quot;// padEnd'hello'.padEnd(10) &quot;hello &quot; 5. Trailing commas in function parameters12345function getMessage(str,str2,){ console.log(`${str} ${str2}`) ;}getMessage(&quot;hello&quot;,&quot;frank&quot;) // hello frank ES9 / ES20181. Asynchronous Iterationfor await of loop support asynchronous iteration 12345async function process(array) { for await (let i of array) { // doSomething(i); }} 2. Promise.finally()1Promise.resolve().then().catch(e =&gt; e).finally(); 3. Rest/Spread Operator12const values = [1, 2, 3, 5, 6];console.log( Math.max(...values) ); // 6 4. Capturing groups in regular expressionDemo 123const regexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/;console.log('2020-04-04'.match(regexp)); // {year: &quot;1995&quot;, month: &quot;12&quot;, day: &quot;13&quot;} ES10 / ES20191. Array.flat() and Array.flatMap()flat() 1[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4] flatMap() 1[1, 2, 3, 4].flatMap(a =&gt; [a**2]); // [1, 4, 9, 16] 2. String.trimStart() and String.trimEnd()trimStart() removes whitespace from the beginning of a string 1234const greeting = ' Hello world! ';console.log(greeting.trimStart());// expected output: &quot;Hello world! &quot;; trimEnd() removes whitespace from the end of a string 1234const greeting = ' Hello world! ';console.log(greeting.trimEnd());// expected output: &quot; Hello world!&quot;; 3. String.prototype.matchAllmatchAll() method returns an iterator of all results matching a string against a regular expression, including capturing groups. 12345678910const regexp = /t(e)(st(\\d?))/g;const str = 'test1 test2';const array = [...str.matchAll(regexp)];console.log(array[0]);// expected output: Array [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]console.log(array[1]);// expected output: Array [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;] 4. Object.fromEntries()Object.fromEntries() method transforms a list of key-value pairs into an object. Converting a Map to an Object 12const map = new Map([ ['foo', 'bar'], ['baz', 42] ]);console.log(Object.fromEntries(map)); // { foo: &quot;bar&quot;, baz: 42 } Converting an Array to an Object 12const arr= [ ['foo', 'bar'], ['baz', 42] ];console.log(Object.fromEntries(arr)); // { foo: &quot;bar&quot;, baz: 42 } 5. Optional catch bindingError parameter is required in try…catch before ES10 12345try { console.log('Foobar')} catch(err) { console.error('Bar')} Error parameter is optional in ES10 12345try { console.log('Foobar')} catch { console.error('Bar')} ES11 / ES20201. Nullish coalescing OperatorNullish coalescing Operator (??) is a logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined, and otherwise returns its left-hand side operand 123456789101112let user = { u1: 0, u2: false, u3: null, u4: undefined, u5: '',}let u1 = user.u1 ?? 'user1' // 0let u2 = user.u2 ?? 'user2' // falselet u3 = user.u3 ?? 'user3' // user3let u4 = user.u4 ?? 'user4' // user4let u5 = user.u5 ?? 'user5' // '' 2. Optional chainingThe Optional chaining (?.) operator functions similarly to the . chaining operator, except that instead of causing an error if a reference is nullish (null or undefined), the expression short-circuits with a return value of undefined. 123let user = {}let u1 = user.children.name // TypeError: Cannot read property 'name' of undefinedlet u1 = user.children?.name // undefined 3. Promise.allSettledThe Promise.allSettled() method returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise. 12345678910111213const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'foo'));const promises = [promise1, promise2];Promise.allSettled(promises).then(results =&gt; { results.forEach(result =&gt; { console.log(result); });});// expected output:// &quot;{ status: &quot;fulfilled&quot;, value: 3 }&quot;// &quot;{ status: &quot;rejected&quot;, reason: &quot;foo&quot; }&quot; 4. import()Before ES11 123456789if (Math.random()) { import 'foo'; // SyntaxError}// You can’t even nest `import` and `export`// inside a simple block:{ import 'foo'; // SyntaxError} You can import module on demand and using [template strings]() 1234567if (condition) { const dynamicModule = import('./module');}let moduleName = 'foo';import(`./modules/${moduleName}.js`); 5. globalThisglobalThis is used to solve the problem that the names of global objects are not uniform in different environments such as browsers and Node.js, and it is troublesome to obtain global objects: 12345678910// how we do it before globalThis existconst getGlobal = function () { // the only reliable means to get the global object is // `Function('return this')()` // However, this causes CSP violations in Chrome apps. if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object');}; ES12 / ES20211. replaceAllThe replaceAll() method returns a new string with all matches of a pattern replaced by a replacement. 12345const str = 'hello world';str.replaceAll('l', ''); // &quot;heo word&quot;const regex = /l/ig;str.replaceAll(regex, 'p'); // heppo worpd 2. Promise.anyPromise.any() takes an iterable of Promise objects and, as soon as one of the promises in the iterable fulfills, returns a single promise that resolves with the value from that promise 123456789const promise1 = Promise.reject(0);const promise2 = new Promise((resolve) =&gt; setTimeout(resolve, 100, 'quick'));const promise3 = new Promise((resolve) =&gt; setTimeout(resolve, 500, 'slow'));const promises = [promise1, promise2, promise3];Promise.any(promises).then((value) =&gt; console.log(value));// expected output: &quot;quick&quot; 3. Logical Assignment OperatorLogical assignment operator combines the logical operations(&amp;&amp;, || or ??) with assignment. 1234567891011a ||= b// equals toa = a || (a = b)a &amp;&amp;= b// equals toa = a &amp;&amp; (a = b)a ??= b// equals toa = a ?? (a = b) Examples 1234let x = 1;let y = 2;x &amp;&amp;= y;console.log(x); // 2 1234let x = 1;let y = 2;x ||= y;console.log(x); // 1 1234let x;let y = 2;x ??= y;console.log(x); // 2 4. Underscores as Numeric Separator1234const billion = 1_000_000_000;console.log(billion); // 10000000001_000_000_000 === 1000000000; // true","link":"/new-javascript-features-in-es6-to-es12/"},{"title":"Web Share API - Native Sharing is Easy!","text":"In this tutorial, you would learn how to use the Web share API in your website or web app. Sharing is easy in native apps but it was always a pain for web, but now Web Share API brings native content sharing to the web. Now you can offer native way to sharer links, text and other content from a web page to desired target. Demo The requirementsThere are requirements before the API is available and can be used: HTTPS Can only be invoked by user action, such as a button click Only title, text, url and files are supported Browser compatibilityThe Web Share API now only works in some browsers, you should check if user’s browser support is eligible to use the API, if it doesn’t, then you should add a fallback option for those browsers. You can check the supported browsers here. Use the code below to check if browser supports the Web Share APIs. 1234567if (navigator.share) { // Web Share API is supported console.log('Thanks for sharing');} else { // Fallback console.error('Web Share API not supported in your browser.');} ExamplesSharing Examples12345678910111213141516171819202122232425async function share() { if (navigator.share) { try { await navigator.share({ url: 'https://shineve.hashnode.dev/', title: &quot;Shineve's &quot;, text: &quot;Shineve's hashnode blog&quot;, }); console.log('Thanks for sharing'); } catch (err) { // User rejected sharing or something goes wrong const { name, message } = err; if (name === 'AbortError') { // User rejected sharing console.log('Share is cancelled.'); } else { // Something goes wrong console.error('Error: ', err); } } } else { // Fallback console.error('Web Share API not supported in your browser.'); }} File Sharing Examples123456789101112131415161718192021222324async function shareFiles() { if (navigator.canShare &amp;&amp; navigator.canShare({ files: filesArray })) { try { await navigator.share({ files: filesArray, title: 'Pictures', text: 'My Pictures.', }); console.log('Thanks for sharing'); } catch (err) { const { name, message } = err; if (name === 'AbortError') { // User rejected sharing console.log('Share is cancelled.'); } else { // Something goes wrong console.error('Error: ', err); } } } else { // Fallback console.error('Web Share API not supported in your browser.'); }} Wrapping upThis article covers pretty much the baseline for what you need to know about the Web Share API. Although browser support is spotty, a fallback can be easily implemented, so more websites should adopt this to let your user share your content more easily across a wider variety of social networks, with contacts and other native apps. If you want to learn more about this API, you can read the specification here. Resources Can I Use - Web Share API MDN - Navigator.share() W3C - Web Share API","link":"/web-share-api/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Web Development","slug":"Web-Development","link":"/tags/Web-Development/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS Postprocessor","slug":"CSS-Postprocessor","link":"/tags/CSS-Postprocessor/"},{"name":"PostCSS","slug":"PostCSS","link":"/tags/PostCSS/"},{"name":"CSS Preprocessor","slug":"CSS-Preprocessor","link":"/tags/CSS-Preprocessor/"},{"name":"Sass","slug":"Sass","link":"/tags/Sass/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Jira","slug":"Jira","link":"/tags/Jira/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"},{"name":"Project Management","slug":"Project-Management","link":"/categories/Project-Management/"}]}