{"pages":[],"posts":[{"title":"Clipboard API - Copy text to clipboard with JavaScript","text":"Copy buttons are often used in many websites and applications, in this tutorial, you would learn how to copy text in your website or web app across all browsers. Demo The Wide Support WayTo appreciate the improved way of copying text to clipboard, we need to take a brief look at how we used to have to do things. 123456789101112131415161718192021222324function wideSupportCopyToClipboard(textToCopy) { // Add a temporary textarea element so that we can later run the copy command const textarea = document.createElement('textarea'); //Add value we want to copy to the textarea textarea.value = textToCopy; // Avoid keyboard open in iOS textarea.readOnly = true; textarea.contentEditable = 'true'; //Append invisible textarea to the document textarea.style.position = 'absolute'; textarea.style.left = '-9999px'; document.body.appendChild(textarea); //select the text to be copied textarea.select(); // Copy the selected text inside the textarea to the clipboard document.execCommand('copy'); //Remove temporary textarea from the document textarea.remove();} Clipboard APIThe Clipboard API to provide copy, cut and paste events as well as provide access to the OS clipboard. This API is intended to replace the need of the document.execCommand() method which is now being deprecated. The awesome part of the Clipboard API is that it provides Async Clipboard API with a well-defined permissions model that doesn’t block the page, it allows us to provide better user experience when transferring time consuming resources. You can check for more details here. The Clipboard API browser compatibility is also now supported in major browsers after Safari recently announced support for it in version 13.1. The New Way12345678910function newWayCopyToClipboard(textToCopy) { navigator.clipboard .writeText(textToCopy) .then(() =&gt; { console.log(&quot;Text copied to clipboard&quot;); }) .catch((error) =&gt; { console.error(&quot;Failed to copy: &quot;, error); });} FinalWe can keep the wide support version to make sure everything goes well when something goes wrong. 12345678910111213async function copyToClipboard(textToCopy) { if (navigator.clipboard &amp;&amp; navigator.clipboard.writeText) { try { await navigator.clipboard.writeText(textToCopy); console.log(&quot;Text copied to clipboard with Clipboard API&quot;); } catch { console.error(&quot;Failed to copy: &quot;, error); wideSupportCopyToClipboard(textToCopy); } } else { wideSupportCopyToClipboard(textToCopy); }} Resources MDN - Clipboard API MDN - Clipboard.writeText() Can I Use - Clipboard API browser Compatibility Unblocking clipboard access - Safer, unblocked clipboard access for text and images","link":"/clipboard-api/"},{"title":"CSS Postprocessor (PostCSS)","text":"以最知名的 PostCSS 為例，它是一個使用 JavaScript 轉換 CSS 的工具，它提供很多的API來分析、修改CSS的規則，因此它可以被利用來開發各種的工具，在拓展性極高的狀況下，它其實並不局限在於後處理。 以下是較常見的 PostCSS Plugins： autoprefixer: 加入各家瀏覽器的前綴詞（prefix），例如：-webkit-、-moz-。 stylelint: 語法檢查和報錯。 postcss-preset-env: 將先進的功能轉為目前主流瀏覽器所能支援的語法。（類似 Babel） postcss-nested: 提供 CSS Nesting 功能。 cssnano: 在不改變CSS的效果為前提下，對CSS檔案做縮減及優化。 Lost Grid: 讓系統支援 Grid System。（通過 calc() 實現因此支援度很高） 優勢 有彈性、好擴充，因為是以 Plugin 的方式插入，未來若主流瀏覽器支援了這些功能，要拔除特定 plugin 是很容易的。 更輕量，不像 Sass 可能預先綁了許多可能用不到的功能。 速度快。由於 PostCSS 的功能由所掛的 Plugin 數量而定，體積小，因此轉換的速度幾乎比 Sass 快三倍。 相對 CSS Preprocessor，更容易撰寫自己所想要的功能，因為使用 PostCSS 是可以自建 Plugin 而不是修改 Library。 Vue 中 PostCSS 的應用 Vue CLI 中就有使用到上方所提的 autoprefixer，來擴大專案的瀏覽器支援度 。 Vue 中有一個非常實用的 Scoped CSS 功能，讓各個 Component 之間的 CSS 不會互相污染，而這項功能正是透過 PostCSS 的協助來完成的。","link":"/css-postprocessor/"},{"title":"CSS Preprocessor","text":"以最知名的 Sass 為例，它提供了許多 CSS 語法的擴充，彌補 CSS 在大型專案維護性的不足，讓開發者可以更有結構地撰寫簡潔、清晰且好維護的 CSS 程式碼。 Sass 常用的有幾種功能： Variables：變數中可以儲存顏色、字型或任何 CSS 值。 Nesting：可巢狀 CSS 選擇器，提供清晰的層次結構。 Mixins：可以定義&amp;重用程式碼塊。 Extend：可以在一個選擇器內繼承另一個選擇器。 Operators：可以在 CSS 中使用操作符進行計算。 @if and @else / @for：可以迴圈/條件生成 CSS。 CSS Preprocessor 可以解決什麼問題？01. 文件切分當頁面越來越複雜，需要加載的 CSS 文件也越來越大，我們有必要把大文件切分開來，否則難以維護。傳統的 CSS 文件切分方案基本上就是 CSS 原生的 @import 指令，或在 HTML 中加載多個 CSS 文件，這些方案通常不能滿足性能要求。 CSS Preprocessor擴展了 @import 指令的能力，通過編譯環節將切分後的文件重新合併為一個大文件。這一方面解決了大文件不便維護的問題，另一方面也解決了一堆小文件在加載時的性能問題。 02. CSS Nesting當我們在撰寫 HTML 時，可以輕易的寫出 DOM 之間嵌套的階層結構，但在傳統的 CSS 做不到，需要重複寫許多父元素選擇器。 12345678910111213.nav { margin: auto; width: 1000px; color: #333;} .nav li { float: left; width: 100px;} .nav li a { display: block; text-decoration: none;} 依賴 CSS Preprocessor 可以直接像在寫程式一樣將父子元素這樣一層一層包起來。這樣我們可以很容易地表達出規則之間的層級關係。 12345678910111213.nav { margin: auto; width: 1000px; color: #333; li { float: left; width: 100px; a { display: block; text-decoration: none; } }} 03. CSS 的重複利用Extends / Mixins 讓 CSS 能更好的被複用，以提高 CSS 的可維護性。Extends 與 Mixins 的最大區別就是 Mixins 可以傳入參數，Extends 只是單純繼承，與 TailwindCSS 的 @apply 效果相同 Mixins 1234567891011121314151617// Mixins@mixin square($size, $radius: 0) { width: $size; height: $size; @if $radius != 0 { border-radius: $radius; }}.avatar { @include square(100px, $radius: 4px);}.card { @include square(300px, $radius: 2px);} 123456789101112// Mixins transpiled result.avatar { width: 100px; height: 100px; border-radius: 4px;}.card { width: 300px; height: 300px; border-radius: 2px;} Extends 123456789101112131415161718192021222324252627282930// Extends%message-shared { border: 1px solid #ccc; padding: 10px; color: #333;}%equal-heights { display: flex; flex-wrap: wrap;}.message { @extend %message-shared;}.success { @extend %message-shared; border-color: green;}.error { @extend %message-shared; border-color: red;}.warning { @extend %message-shared; border-color: yellow;} 123456789101112131415161718// Extends transpiled result.warning, .error, .success, .message { border: 1px solid #ccc; padding: 10px; color: #333;}.success { border-color: green;}.error { border-color: red;}.warning { border-color: yellow;} 推薦閱讀風格指南 Sass Style Guide 專案結構 The 7-1 Pattern 1234567891011121314151617181920212223242526272829303132333435363738sass/||– abstracts/ （or utilities/)| |– _variables.scss // Sass Variables| |– _functions.scss // Sass Functions| |– _mixins.scss // Sass Mixins||– base/| |– _reset.scss // Reset/normalize| |– _typography.scss // Typography rules||– components/ (or modules/)| |– _buttons.scss // Buttons| |– _carousel.scss // Carousel| |– _slider.scss // Slider||– layout/| |– _navigation.scss // Navigation| |– _grid.scss // Grid system| |– _header.scss // Header| |– _footer.scss // Footer| |– _sidebar.scss // Sidebar| |– _forms.scss // Forms||– pages/| |– _home.scss // Home specific styles| |– _about.scss // About specific styles| |– _contact.scss // Contact specific styles||– themes/| |– _theme.scss // Default theme| |– _admin.scss // Admin theme||– vendors/| |– _bootstrap.scss // Bootstrap| |– _jquery-ui.scss // jQuery UI|`– main.scss // Main Sass file","link":"/css-preprocessor/"},{"title":"GitHub &amp; Jira Automation","text":"Automation had been setup in DEV project, if you pass in a valid ticket ID, the referenced issue will transit automatically depending on your action to save you a little time to adjust the issue status yourself. Check out GitHub actions if you are interested how the automation works. What is a ticket ID?You can find the ticket ID from the bottom left corner of your issue card. ticket ID example: NGT-194 is the ticket ID. How to name your branch1&lt;ticket-id&gt;/&lt;branch-type&gt;_&lt;branch-name&gt; (**DEV-112/feature_user-login**) Supported Actions Create Branches Branch name example: DEV-112/feature_user-login Issue will automatically transit from To Do to In Progress . Create Commits Commit name example: “DEV-112 Initial commit” Issue will automatically transit from To Do to In Progress . Create Pull Requests Pull Requests name example: “[DEV-112] Feature Login User” Multiple Issues example: “[DEV-111 DEV-112 DEV-113] Feature User Management” All Issues will automatically transit from In Progress to Code Review . Pull Requests Approved Issue will automatically transit from Code Review to Deploy . Pull Requests Declined Issue will automatically transit from Code Review to In Progress . View the development panelIf everything has been set up correctly, you will see a development panel on each of your issues, similar to the screenshot below. The development panel provides you with just enough information to evaluate the status of an issue’s development at a glance. ResourcesHow To Reference issues in Jira Process issues with smart commits","link":"/github-and-jira-automation/"},{"title":"New JavaScript Features in ES6 ~ ES12","text":"This article includes the most commonly used features released from ES6 to ES12. To use those features in front end, you will need to use the babel to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. ES6 / ES20151. class12345678910class Man { constructor(name) { this.name = name; } console() { console.log(this.name); }}const man = new Man('Hao');man.console(); // Hao 2. ES Module12345// export function in module Aexport const sub = (a, b) =&gt; a + b;// import function in module Bimport { sub } from './A';console.log(sub(1, 2)); // 3 3. Arrow functions12const func = (a, b) =&gt; a + b;func(1, 2); // 3 4. Default parameters123function foo(age = 25) { console.log(age); // 25} 5. Template strings123const name = 'Hao';const str = `Your name is ${name}`;console.log(str); // Your name is Hao 6. Destructuring assignment12let a = 1, b= 2;[a, b] = [b, a]; // a 2 b 1 7. Spread operator1let a = [...'hello world']; // [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;] 8. Object property value shorthand123const name = 'Hao',const obj = { name };console.log(obj); // { name: 'Hao' } 9. Promise123Promise.resolve().then(() =&gt; { console.log(2); });console.log(1);// print 1 ，then 2 10. let &amp; const12let name = 'Hao'；const arr = []; ES7 / ES20161. Array.prototype.includes()1[1].includes(1); // true 2. Exponentiation operator123console.log(2 ** 10); // 1024console.log(3 ** 4); // 81console.log(2 ** 3 ** 2); // 512 ES8 / ES20171. async/await1234async getData(){ const res = await api.getTableData(); // await asynchronous task // do something} 2. Object.values()1Object.values({a: 1, b: 2, c: 3}); // [1, 2, 3] 3. Object.entries()1Object.entries({a: 1, b: 2, c: 3}); // [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]] 4. String padding1234// padStart'hello'.padStart(10); // &quot; hello&quot;// padEnd'hello'.padEnd(10) &quot;hello &quot; 5. Trailing commas in function parameters12345function getMessage(str,str2,){ console.log(`${str} ${str2}`) ;}getMessage(&quot;hello&quot;,&quot;frank&quot;) // hello frank ES9 / ES20181. Asynchronous Iterationfor await of loop support asynchronous iteration 12345async function process(array) { for await (let i of array) { // doSomething(i); }} 2. Promise.finally()1Promise.resolve().then().catch(e =&gt; e).finally(); 3. Rest/Spread Operator12const values = [1, 2, 3, 5, 6];console.log( Math.max(...values) ); // 6 4. Capturing groups in regular expressionDemo 123const regexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/;console.log('2020-04-04'.match(regexp)); // {year: &quot;1995&quot;, month: &quot;12&quot;, day: &quot;13&quot;} ES10 / ES20191. Array.flat() and Array.flatMap()flat() 1[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4] flatMap() 1[1, 2, 3, 4].flatMap(a =&gt; [a**2]); // [1, 4, 9, 16] 2. String.trimStart() and String.trimEnd()trimStart() removes whitespace from the beginning of a string 1234const greeting = ' Hello world! ';console.log(greeting.trimStart());// expected output: &quot;Hello world! &quot;; trimEnd() removes whitespace from the end of a string 1234const greeting = ' Hello world! ';console.log(greeting.trimEnd());// expected output: &quot; Hello world!&quot;; 3. String.prototype.matchAllmatchAll() method returns an iterator of all results matching a string against a regular expression, including capturing groups. 12345678910const regexp = /t(e)(st(\\d?))/g;const str = 'test1 test2';const array = [...str.matchAll(regexp)];console.log(array[0]);// expected output: Array [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]console.log(array[1]);// expected output: Array [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;] 4. Object.fromEntries()Object.fromEntries() method transforms a list of key-value pairs into an object. Converting a Map to an Object 12const map = new Map([ ['foo', 'bar'], ['baz', 42] ]);console.log(Object.fromEntries(map)); // { foo: &quot;bar&quot;, baz: 42 } Converting an Array to an Object 12const arr= [ ['foo', 'bar'], ['baz', 42] ];console.log(Object.fromEntries(arr)); // { foo: &quot;bar&quot;, baz: 42 } 5. Optional catch bindingError parameter is required in try…catch before ES10 12345try { console.log('Foobar')} catch(err) { console.error('Bar')} Error parameter is optional in ES10 12345try { console.log('Foobar')} catch { console.error('Bar')} ES11 / ES20201. Nullish coalescing OperatorNullish coalescing Operator (??) is a logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined, and otherwise returns its left-hand side operand 123456789101112let user = { u1: 0, u2: false, u3: null, u4: undefined, u5: '',}let u1 = user.u1 ?? 'user1' // 0let u2 = user.u2 ?? 'user2' // falselet u3 = user.u3 ?? 'user3' // user3let u4 = user.u4 ?? 'user4' // user4let u5 = user.u5 ?? 'user5' // '' 2. Optional chainingThe Optional chaining (?.) operator functions similarly to the . chaining operator, except that instead of causing an error if a reference is nullish (null or undefined), the expression short-circuits with a return value of undefined. 123let user = {}let u1 = user.children.name // TypeError: Cannot read property 'name' of undefinedlet u1 = user.children?.name // undefined 3. Promise.allSettledThe Promise.allSettled() method returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise. 12345678910111213const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'foo'));const promises = [promise1, promise2];Promise.allSettled(promises).then(results =&gt; { results.forEach(result =&gt; { console.log(result); });});// expected output:// &quot;{ status: &quot;fulfilled&quot;, value: 3 }&quot;// &quot;{ status: &quot;rejected&quot;, reason: &quot;foo&quot; }&quot; 4. import()Before ES11 123456789if (Math.random()) { import 'foo'; // SyntaxError}// You can’t even nest `import` and `export`// inside a simple block:{ import 'foo'; // SyntaxError} You can import module on demand and using [template strings]() 1234567if (condition) { const dynamicModule = import('./module');}let moduleName = 'foo';import(`./modules/${moduleName}.js`); 5. globalThisglobalThis is used to solve the problem that the names of global objects are not uniform in different environments such as browsers and Node.js, and it is troublesome to obtain global objects: 12345678910// how we do it before globalThis existconst getGlobal = function () { // the only reliable means to get the global object is // `Function('return this')()` // However, this causes CSP violations in Chrome apps. if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object');}; ES12 / ES20211. replaceAllThe replaceAll() method returns a new string with all matches of a pattern replaced by a replacement. 12345const str = 'hello world';str.replaceAll('l', ''); // &quot;heo word&quot;const regex = /l/ig;str.replaceAll(regex, 'p'); // heppo worpd 2. Promise.anyPromise.any() takes an iterable of Promise objects and, as soon as one of the promises in the iterable fulfills, returns a single promise that resolves with the value from that promise 123456789const promise1 = Promise.reject(0);const promise2 = new Promise((resolve) =&gt; setTimeout(resolve, 100, 'quick'));const promise3 = new Promise((resolve) =&gt; setTimeout(resolve, 500, 'slow'));const promises = [promise1, promise2, promise3];Promise.any(promises).then((value) =&gt; console.log(value));// expected output: &quot;quick&quot; 3. Logical Assignment OperatorLogical assignment operator combines the logical operations(&amp;&amp;, || or ??) with assignment. 1234567891011a ||= b// equals toa = a || (a = b)a &amp;&amp;= b// equals toa = a &amp;&amp; (a = b)a ??= b// equals toa = a ?? (a = b) Examples 1234let x = 1;let y = 2;x &amp;&amp;= y;console.log(x); // 2 1234let x = 1;let y = 2;x ||= y;console.log(x); // 1 1234let x;let y = 2;x ??= y;console.log(x); // 2 4. Underscores as Numeric Separator1234const billion = 1_000_000_000;console.log(billion); // 10000000001_000_000_000 === 1000000000; // true","link":"/new-javascript-features-in-es6-to-es12/"},{"title":"How Vue Scoped CSS Works?","text":"Vue 中的 Scoped CSS 是透過 HTML 的 data-* attribute 來達成的，data-* attribute 讓我們可以在 HTML Element 上自定義添加一些自己需要用到的屬性名稱，以方便自己容易理解。 123&lt;div class=&quot;example&quot; data-source=&quot;facebook&quot;&gt; &lt;span&gt;Text from Facebook&lt;/span&gt;&lt;/div&gt; 它也支援我們透過 CSS 和 JavaScript 來取得 data-* attribute 的屬性值。 透過 CSS 取得或選取 data-*attribute我們可以透過 CSS Attribute Selectors來選取指定的 Element。 1234/* CSS */.example[data-source=&quot;facebook&quot;] { color: blue;} 使用 JS 取得 data-* attribute 的屬性值當我們要取得 data-* attribute 的屬性值時，我們可以簡單利用 JavaScript 中的 dataset 物件，就可以取得其中的內容。 123// Javascriptconst el = document.querySelector('.example');console.log(el.dataset.source) // facebook Scoped CSS in VueVue 在打包時，每個 .vue 檔的會根使用當前檔案的 hash 來做為 [data-* attribute]，綁定在在每一個 Element 及 CSS selector 上，來達到 Component 之間互不污染的效果。 123456789101112131415161718// Parent.vue //&lt;template&gt; &lt;div class=&quot;example&quot;&gt;I'm a &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'Parent', };&lt;/script&gt;// Notice the `scoped` attribute on the style tag.&lt;style scoped&gt; .example { font-size: 1.5em; background-color: blue; }&lt;/style&gt; Transpiled: 12345678910111213141516171819// Parent.vue (transpiled) //&lt;template&gt; // 可以看到這邊產生了一個 data-* attribute &lt;div class=&quot;example&quot; data-v-123456&gt;I'm a &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'Parent', };&lt;/script&gt;&lt;style scoped&gt; /* 可以看到這邊產生了一個 data-* attribute */ .example[data-v-123456] { font-size: 1.5em; background-color: blue; }&lt;/style&gt;","link":"/how-vue-css-scoped-works/"},{"title":"「偽隨機」和「真隨機」的應用","text":"在許多應用，尤其是遊戲相關的應用，我們都會需要使用到隨機來實做一些功能，例如：掉寶，開箱、抽卡、洗牌等等。 在程式中實現隨機，又可以分為「真隨機」及「偽隨機」。 在討論「真隨機」及「偽隨機」之前，我們先了解我們程式中常用到的虛擬亂數產生器（PRNGs）。 虛擬亂數產生器 是一個可以產生虛擬亂數序列的算法，但 PRNG 生成的亂數序列並不是「真隨機」，因此它完全由一個初始值決定，這個初始值被稱為 PRNG 的隨機種子（seed，但這個種子可能包含真隨機數）。 Demo 1234// example of 1 seed always generate same resultconsole.log(randomNumber(5)); // 0.8975141500470741console.log(randomNumber(5)); // 0.8975141500470741console.log(randomNumber(5)); // 0.8975141500470741 PRNG 雖然並不是「真隨機」，並且我們有其他的方式可以產生「真隨機」序列，但 PRNG 的生成速度迅速，並且可重現，因此再實踐中我們更常使用到 PRNG。 程式原理上的真偽隨機真隨機「真隨機」又名「純隨機」就是我們平常一直說的那種、一般意義上的「隨機」。在「真隨機」中，每一個事件都是相互獨立、服從「真隨機」分布的，不受其他事件的發生而改變。但在程式裡，不存在「不確定」的數字，只有確定的「1」和「0」，因此程式不能自己生成「隨機」的東西。在程式原理上，「真隨機」的定義是指透過外部的硬體設備，來進行監測或觀測某個真正隨機的事物的狀態，來取得一個隨機數。 例如，random.org 就提供線上的隨機數產生服務，它是透過設備監測大氣中的噪音來得到隨機數。 所以，採用「真隨機」對於程式來說，成本極高效率極低，因此在實踐中，沒有人會買設備去做「真隨機」。 偽隨機「偽隨機」是在不確定性的隨機事件當中，通過一系列算法來讓隨機事件分布的更均勻，儘可能減少或消除極端情況的發生。我們可以理解「偽隨機」就是透過人為創造出來的機制，來讓隨機事件分佈均勻的同時，也還是保留一定的隨機性。 為什麼會需要「偽隨機」呢？比方說某款遊戲為了吸引用戶，擁有這麼一個隨機抽卡系統：每次抽卡時，都有 1%的機率抽出 SSR 卡片，並且這個概率服從「真隨機」分布。 一般用戶會認為，連抽 100 次一定能抽到一張，但實際上，連抽 100 次卻抽不出 1%的 SSR 卡的機率是為(1-0.01)^100=36.6%，甚至還超過了 1/3。將連抽數字上升至 300，也仍有 4.9%的機率。 假設有 10000 個玩家連抽 100 次，就有約 3660 個玩家抽不出這張 SSR；10000 個玩家連抽 300 次，也仍有約 490 個玩家抽不出這張 SSR。 這對玩家的遊戲體驗來說可以說是毀滅性的打擊，儘管「真隨機」就是如此操作的，但玩家在抽卡的時候可不會想那麼多，因此會需要「偽隨機」來讓抽獎這類的遊戲體驗更佳。 常見的偽隨機算法及應用GitHub 範例偽隨機分佈 (Pseudo-Random Distribution) 輪盤抽獎手游裡面常見的可以累計幸運值的輪盤，得獎率初始為 N%，每抽一次得獎率翻倍直到抽中為止，抽中後得獎率重置。 暴擊率像 Dota / LoL 這類競技類遊戲中，連續數次的「走運」會大大的影響遊戲的競技性和觀賞性。因此這類競技類遊戲中，會有很多「偽隨機」機制來避免極端的狀況發生例如：遊戲中的暴擊率 20% 並不是每一刀都是 20% 暴擊率，而是以 5.57%作為初始暴率，如果第一刀不暴，則第二刀的暴率增加到初始值的 2 倍：11.14%，如果還是不暴，就繼續增加到初始值的 3 倍：16.71%，以此類推。至到打出暴擊後，暴擊率重置為 5.57%。 保底機制 (Pity Timer) 抽卡手游裡面常見的抽 N 次必得 SSR，為抽卡事件加保底次數，每次抽卡皆為「真隨機」，直到事件連續不發生的次數高於保底次數，讓事件強制發生。 洗牌算法 撲克牌 音樂播放器歌單有 20 首歌，就建立一個 1 到 20 的數組，再把這 20 個數字像洗牌一樣洗成亂序。在洗完之後，如果第一個數字是 n，第一次就播放歌單裡的第 n 首歌。以此類推。早期的音樂播放器的隨機播放就是採取「真隨機」，但就發現經常會連續播放到同一首歌或者在幾首歌之間來回切換，某一些歌就是永遠播放不到。 限額抽獎假設一個抽獎活動只有 1000 個名額，並且獎品項目都已確定，可以先將所有獎品項目都產生進一個陣列，用戶依次從該陣列中抽取獎品，也就結果一開始就已經確定了，但對用戶來說是隨機的。","link":"/random-and-pseudo-random/"},{"title":"Resource Hints - preconnect, dns-prefetch","text":"當瀏覽器需要對別的 domain 下的資源請進行求的時候，瀏覽器必須與該伺服器建立連線。 建立一個安全的連線包含以下三個步驟 DNS Lookup TCP Handshake (HTTPS connection) SSL Negotiation 上面的 3 個步驟中，每一步都會需要一個 RTT (Round Trip Time) 的來回時間。所以在實際傳輸資料之前，已經花了 3 個 RTT 的時間。如果在網路狀況很差的狀況下，會讓獲取資源的速度大大降低。 我們可以透過 &lt;link rel=preconnect&gt; 和 &lt;link rel=dns-prefetch&gt; 來提前處理好以上的連線，就可以讓網頁整體的載入速度更迅速。 rel=preconnect 如果我們知道網站需要對哪個 domain 的資源進行請求時，我們就可以利用 rel=preconnect 提早建立好與特定 domain 之間的連線。這讓我在請求的當下省去了一次完整的 (DNS Lookup + TCP Handshake + SSL Negotiation) ，共三個 RTT 的時間。 假設當前網站是 https://a.com ，這個網站的首頁需要請求 https://b.com/b.js 這個資源。對比正常請求和配置了 rel=preconnect 時候的請求，它們在 waterfall 上看到的表現是不一樣的： 通過如下配置可以提前建立和 https://b.com 這個域的連線： 1&lt;link rel=&quot;preconnect&quot; href=&quot;https://b.com&quot;&gt; 通過 preconnect 提早建立和第三方源的連線，可以將資源的載入時間縮短 100ms ~ 500ms，這個時間雖然看起來微不足道，但是它是實實在在的優化了頁面的效能，提升了使用者的體驗。 preconnect 應用場景通常只會對確定短時間內就會用到的 domain 做 preconnect ，因為如果 10 秒內沒有使用的話，瀏覽器會自動把連線 close 掉。 例子一：CDN如果網站會從某個 CDN 請求很多資源（例如 image CDN），但又不確定會載入哪些資源時，可以對 CDN 做 preconnect 。 例子二：Streaming 串流媒體例如我們希望用戶手動去點擊開始才載入媒體資源而不是進入頁面就做載入，我們可以在使用者鼠標移到元件範圍時，對媒體資源 domain 做 preconnect ，這樣當使用者真的點下播放鍵時可以更快速的播放影片。 rel=dns-prefetch 跟 preconnect 類似，差別在於 dns-prefetch 只預先處理第一步 DNS Lookup 而已。也就是說 dns-preconnect = DNS Lookuppreconnect = DNS look up + TCP Handshake + SSL Negotiation 另外由於 preconnect 的瀏覽器相容稍微比 dns-prefetch 低，因此 dns-prefetch 可以作為不支援預連線的瀏覽器的後備選擇，同時配置它們兩即可： 12&lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.bootcss.com&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://cdn.bootcss.com&quot;&gt; ** dns-prefetch vs preconnect ** 既然能通過 preconnect 來減少整個建立連線的時間，那為什麼還需要 dns-prefetch 來減少建立連線中第一步 DNS 查詢解析的時間呢？ preconnect 所耗費的資源是比較多的，因此當我們確定短時間內就會向某個 domain 發送請求的話，就可以使用 preconnect 。 如果某一些請求是偶爾才會發生的話，則使用 dns-prefetch 即可。這樣可以避免無用的 TCP Handshake 及 SSL Negotiation 發生。","link":"/resource-hints-preconnect-dns-prefetch/"},{"title":"Resource Hints - preload, prefetch","text":"preload每一個類型的資源在瀏覽器中都有默認的載入優先順序，而 preload 就是能夠提升資源載入的優先順序，使得它的載入會提早開始（預載入），在需要用的時候能夠更快的使用上。 Resource Type Priority HTML Highest Fonts High Stylesheets Highest Stylesheets loaded with @import Highest, will be queued after blocking scripts. Images Default priority Low, upgraded to Medium when rendered in the initial viewport. JavaScript Low, Medium or High. See Addy Osmani’s JavaScript Loading Priorities in Chrome for more details. Ajax, XHR, or fetch() API High 當某個頁面載入了 2 個指令碼 jquery.min.js 和 test.js ： 12&lt;script src=&quot;https://cdn.jsdelivr.net/npm/faker@5.5.3/index.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; 此時該頁面的資源載入 Waterfall 長這樣： 當在 &lt;head&gt; 裡通過 &lt;link&gt; 標籤給 test.js 配置 preload 預載入後： 1&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot;./test.js&quot;&gt; 此時的 test.js 載入順序出現在了 jquery.min.js 的前面，這就是 preload 提升資源載入優先順序的效果。 可以看到 test.js 的 queued time 是比 jquery.min.js 來的早的 通過 &lt;link rel=&quot;preload&quot;&gt; 只是預載入了資源，但是資源載入完成後並不會執行，所以需要在想要執行的地方通過 &lt;script&gt; 來引入它： 1&lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; CSS 的載入也是通過 &lt;link&gt; 標籤引入的，所以我們可以巧妙的利用這點，當 onload 事件觸發的時候修改 rel 屬性的值，使得它由原來的預載入樣式變成引入樣式： 123456&lt;link rel=&quot;preload&quot; as=&quot;style&quot; onload=&quot;this.rel='stylesheet'&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.0.1/css/bootstrap.min.css&quot;/&gt; preload應用場景 案例一：預載入定義在 CSS 中資源的下載，比如自定義字型當頁面中使用了自定義字型的時候，就必須在 CSS 中引入該字型，而由於字型必須要等到瀏覽器下載完且解析該 CSS 檔案的時候才開始下載，所以對應頁面上該字型處可能會出現閃動的現象，為了避免這種現象的出現，就可以使用 preload 來提前載入字型， type 可以用來指定具體的字型型別，載入字型必須指定 crossorigin 屬性，否則會導致字型被載入兩次。 1&lt;link rel=&quot;preload&quot; as=&quot;font&quot; crossorigin type=&quot;font/woff2&quot; href=&quot;myfont.woff2&quot;&gt; 案例二：預載入 CSS 檔案在首屏載入優化中一直存在一種技術，叫做抽取關鍵 CSS ，意思就是把頁面中在視口中出現的樣式抽出一個獨立的 CSS 檔案出來 critical.css ，然後剩餘的樣式在放到另外一個檔案上 non-critical.css ： 由於 CSS 會阻塞頁面的渲染，當同時去載入這 2 部分樣式的時候，只要 non-critical.css 還沒載入完成，那麼頁面就顯示不了，而實際上只需要顯示出視口下的介面即可，所以期待的結果是：當載入完成 critical.css 的時候馬上顯示出視口下的介面，不讓 non-critical.css 阻塞渲染，則需要給 non-critical.css 加上預載入： 1&lt;link rel=&quot;preload&quot; as=&quot;style&quot; onload=&quot;this.rel='stylesheet'&quot; href=&quot;./non-critical.css&quot; /&gt; Prefetch preload 用於提前載入用於當前頁面的資源，而 prefetch 則是用於載入未來（比如下一個頁面）會用到的資源，並且告訴瀏覽器在空閒的時候去下載，它會將下載資源的優先順序降到最低。 比如在首頁配置如下程式碼： 1&lt;link rel=&quot;prefetch&quot; as=&quot;script&quot; href=&quot;https://cdn.jsdelivr.net/npm/faker@5.5.3/index.min.js&quot; /&gt; 我們會在頁面中看到該指令碼的下載優先順序已經被降低為 Lowest ： 當資源被下載完成後，會被存到瀏覽器快取中，當從首頁跳轉到頁面 A 的時候，假如頁面 A 中引入了該指令碼，那麼瀏覽器會直接從 prefetch cache 中讀取該資源，從而實現資源載入優化。","link":"/resource-hints-preload-prefetch/"},{"title":"Script Tag - async &amp; defer","text":"通過標籤 async 和 defer，我們可以調整網頁所引入的 JavaScript 文件的執行順序。 將 &lt;script&gt; 加在 &lt;head&gt; 瀏覽器一旦解析到 &lt;script&gt; 就會 停止解析 對 script 發起請求 下載 script 執行 script 完成後繼續向下解析 在以上的過程中，每個過程之間會有網路延遲，過程中會導致整個瀏覽器解析卡住，無法繼續渲染。 將 &lt;script&gt; 加在 &lt;body&gt; 的最後 瀏覽器解析過程與上面相同，但因為 &lt;script&gt; 被放在最後，所以頁面的內容會先完全呈現在瀏覽器中，用戶也會因為空白畫面的時間縮短而感到速度變快了。 script defer 瀏覽器一旦解析到 defer 的 &lt;script&gt; 時就會 對 script 發起請求 下載 script 在瀏覽器解析完 HTML 之後才執行 script defer 會從上到下按照順序執行 script 使用 defer 的效果與放在 &lt;body&gt; 最後類似，但請求會更早的被發出，所以整體的加載時間會縮短。 script async 瀏覽器一旦解析到 async 的 &lt;script&gt; 就會 對 script 發起請求 下載 script 下載完成後停止解析 HTML 執行 script 完成後繼續向下解析 HTML 解析過程與將 &lt;script&gt; 加在 &lt;head&gt; 的效果類似，但 script 會在下載完成後才執行，所以整體的加載時間會縮短。 執行順序defer 會根據在 HTML 中的先後順序來依次執行。 async 在下載完之後就會執行。 何時使用defer 會在 DOM 載完後才執行，因此大部分場景都可以使用。 async 會在下載完之後就執行，因此無法掌握它的執行時間點，因此只能用在完全可以單獨使用的 script ，同時也是不會操作 DOM 的 script 。例：Google Analytics","link":"/script-tag-async-and-defer/"},{"title":"Web Share API - Native Sharing is Easy!","text":"In this tutorial, you would learn how to use the Web share API in your website or web app. Sharing is easy in native apps but it was always a pain for web, but now Web Share API brings native content sharing to the web. Now you can offer native way to sharer links, text and other content from a web page to desired target. Demo The requirementsThere are requirements before the API is available and can be used: HTTPS Can only be invoked by user action, such as a button click Only title, text, url and files are supported Browser compatibilityThe Web Share API now only works in some browsers, you should check if user’s browser support is eligible to use the API, if it doesn’t, then you should add a fallback option for those browsers. You can check the supported browsers here. Use the code below to check if browser supports the Web Share APIs. 1234567if (navigator.share) { // Web Share API is supported console.log('Thanks for sharing');} else { // Fallback console.error('Web Share API not supported in your browser.');} ExamplesSharing Examples12345678910111213141516171819202122232425async function share() { if (navigator.share) { try { await navigator.share({ url: 'https://shineve.hashnode.dev/', title: &quot;Shineve's &quot;, text: &quot;Shineve's hashnode blog&quot;, }); console.log('Thanks for sharing'); } catch (err) { // User rejected sharing or something goes wrong const { name, message } = err; if (name === 'AbortError') { // User rejected sharing console.log('Share is cancelled.'); } else { // Something goes wrong console.error('Error: ', err); } } } else { // Fallback console.error('Web Share API not supported in your browser.'); }} File Sharing Examples123456789101112131415161718192021222324async function shareFiles() { if (navigator.canShare &amp;&amp; navigator.canShare({ files: filesArray })) { try { await navigator.share({ files: filesArray, title: 'Pictures', text: 'My Pictures.', }); console.log('Thanks for sharing'); } catch (err) { const { name, message } = err; if (name === 'AbortError') { // User rejected sharing console.log('Share is cancelled.'); } else { // Something goes wrong console.error('Error: ', err); } } } else { // Fallback console.error('Web Share API not supported in your browser.'); }} Wrapping upThis article covers pretty much the baseline for what you need to know about the Web Share API. Although browser support is spotty, a fallback can be easily implemented, so more websites should adopt this to let your user share your content more easily across a wider variety of social networks, with contacts and other native apps. If you want to learn more about this API, you can read the specification here. Resources Can I Use - Web Share API MDN - Navigator.share() W3C - Web Share API","link":"/web-share-api/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Web Development","slug":"Web-Development","link":"/tags/Web-Development/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS Postprocessor","slug":"CSS-Postprocessor","link":"/tags/CSS-Postprocessor/"},{"name":"PostCSS","slug":"PostCSS","link":"/tags/PostCSS/"},{"name":"CSS Preprocessor","slug":"CSS-Preprocessor","link":"/tags/CSS-Preprocessor/"},{"name":"Sass","slug":"Sass","link":"/tags/Sass/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Jira","slug":"Jira","link":"/tags/Jira/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Product Design","slug":"Product-Design","link":"/tags/Product-Design/"}],"categories":[{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"},{"name":"Project Management","slug":"Project-Management","link":"/categories/Project-Management/"}]}